[{"title":"关于浮点损失与精度问题","date":"2021-02-06T16:36:31.000Z","url":"/2021/02/07/%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B5%AE%E7%82%B9%E6%8D%9F%E5%A4%B1%E4%B8%8E%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/%E5%85%B3%E4%BA%8E%E6%B5%AE%E7%82%B9%E6%8D%9F%E5%A4%B1%E4%B8%8E%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98/","categories":[["杂记","/categories/%E6%9D%82%E8%AE%B0/"]],"content":"《关于一道 ABC 的 D 题我却提交了整整三页这件事》 ABC#191 D卡精度原因是浮点数其实是二进制表示的，然而总有无法完美表示的浮点数。其实$IEEE754$怎么算的我已经忘了 比如下面这个例子 Input Output 面对卡精度题，一个较好的做法是把double转成long long来运算 然而double转long long就有一个坑。。。就是上面的代码，直接乘会出事 方法有两个 换一个读入方式，比如字符串读入 使用d = round(x * 10000)来替代d = x * 10000 还有一些其他的坑点，比如转换数字过大时考虑使用long double和__int128 希望下次碰见精度问题的时候自己不要忘了这篇博客 铭 记 历 史 "},{"title":"NamomoCamp-day5-线段树","date":"2021-01-31T23:28:16.000Z","url":"/2021/02/01/NamomoCamp/NamomoCamp-day5-%E7%BA%BF%E6%AE%B5%E6%A0%91/","categories":[["NamomoCamp","/categories/NamomoCamp/"]],"content":"Solution for NamomoCamp2021-div2-day5-线段树 Subsequence Count (hdu 6155) Tag dp， 矩阵，线段树 Solution Code "},{"title":"NamomoCamp-day1-dp","date":"2021-01-31T20:39:03.000Z","url":"/2021/02/01/NamomoCamp/NamomoCamp-day1-dp/","categories":[["NamomoCamp","/categories/NamomoCamp/"]],"content":"Solution for NamomoCamp2021-div2-day1-dp New Year and Original Order (Good Bye 2017 G) Tag 数位dp Solution 用$f[d][i]$表示数字$d$在第$i$位上出现的次数，假设我们已知所有$f[d][i]$，则有 ans=\\sum_{d=0}^{9}\\sum_{i=1}^{N}(f[d][i]\\times10^{i-1}\\times d)可惜的是$f[d][i]$未知，直接求$f[d][i]$也很难求 考虑下性质：所有数字升序排序，转化一下求$f[d][i]$的思路，用$g[d][i]$表示$\\ge d$的数字出现$\\ge i$次的次数，那么有$f[d][i]=g[d][i]-g[d+1][i]$ $g[d][i]$依旧不好直接求，但可以先求$h[d][i]$：$\\ge d$的数字出现恰好$i$次的次数，$g[d][i]=\\sum_{j=i}^{n}h[d][j]$ $h$就可以直接求了，数位dp一下即可，状态$h[pos][d][i][limit]$，状态数$O(10N^2)$ $k$表示当前位枚举的数字，转移式 h[pos][d][i]= \\begin{cases} h[pos+1][d][i]& k"}]